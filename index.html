<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>åˆ‡æ³¡æ³¡ å­¸å› æ•¸</title>
    <style>
        /* --- åŸºç¤è¨­å®š & iPad å„ªåŒ– --- */
        @import url('https://fonts.googleapis.com/css2?family=Varela+Round&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #FFF1EB 0%, #ACE0F9 100%);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: 'Varela Round', sans-serif;
            height: 100vh;
            width: 100vw;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- UI å±¤ (HUD) --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            padding-top: max(20px, env(safe-area-inset-top)); 
            height: 15%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 20px;
            padding-right: 20px;
        }

        .score-box, .timer-box {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(8px);
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 26px;
            color: #555;
            box-shadow: 0 4px 15px rgba(0,0,0,0.12);
            font-weight: bold;
        }

        .safe-zone-bottom {
            height: 15%;
            border-top: 2px dashed rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(0,0,0,0.2);
            font-size: 14px;
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* --- å½ˆå‡ºè¦–çª— --- */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
            transition: opacity 0.3s;
        }

        .modal.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 52px;
            color: #FF9A9E;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0px #fff;
            text-align: center;
        }

        p {
            font-size: 20px;
            color: #666;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.8;
            max-width: 85%;
        }

        .btn {
            background: linear-gradient(135deg, #FF9A9E 0%, #FBC2EB 100%);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 26px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(255, 154, 158, 0.5);
            font-family: 'Varela Round', sans-serif;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 154, 158, 0.6);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .stat-big {
            font-size: 72px;
            color: #A18CD1;
            margin: 15px 0;
            font-weight: bold;
            text-shadow: 2px 2px 0px rgba(161, 140, 209, 0.2);
        }

        .record-info {
            font-size: 16px;
            color: #888;
            margin-top: 5px;
            margin-bottom: 25px;
        }

        .high-score-display {
            background: rgba(255, 215, 61, 0.2);
            padding: 15px 30px;
            border-radius: 20px;
            margin-bottom: 20px;
        }

        .high-score-label {
            font-size: 16px;
            color: #999;
            margin-bottom: 5px;
        }

        .high-score-value {
            font-size: 36px;
            color: #FFD93D;
            font-weight: bold;
        }

        .instruction {
            font-size: 16px;
            color: #999;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="hud-top">
            <div class="score-box">ğŸŒŸ <span id="scoreDisplay">0</span></div>
            <div class="timer-box">â±ï¸ <span id="timeDisplay">60</span>s</div>
        </div>
        <div class="safe-zone-bottom">
            <span>è³ªæ•¸è½åœ°å€ (Safe Zone)</span>
        </div>
    </div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="startScreen" class="modal">
        <h1>ğŸˆ åˆ‡æ³¡æ³¡ å­¸å› æ•¸</h1>
        <p>
            æ‰¾å‡º<b style="color:#FF9A9E;">åˆæˆæ•¸</b>ä¸¦åˆ‡é–‹å®ƒï¼<br>
            å°å¿ƒä¸è¦åˆ‡åˆ°<b style="color:#A18CD1;">è³ªæ•¸</b>å–”ï¼<br>
            è®“è³ªæ•¸å®‰å…¨è½åœ°å¯å¾—é«˜åˆ† ğŸ’¯
        </p>
        <div class="high-score-display">
            <div class="high-score-label">æ­·å²æœ€é«˜åˆ†</div>
            <div class="high-score-value" id="homeHighScore">--</div>
            <div class="record-info" id="homeHighScoreDate">--</div>
        </div>
        <button class="btn" onclick="startGame()">ğŸš€ é–‹å§‹éŠæˆ²</button>
        <p class="instruction">ğŸ’¡ è³ªæ•¸æœƒè‡ªå‹•åŠ é€Ÿä¸‹è½ï¼Œä¸ç”¨æ“”å¿ƒå¡ä½</p>
    </div>

    <!-- çµæŸç•«é¢ -->
    <div id="endScreen" class="modal hidden">
        <h1>â° æ™‚é–“åˆ°ï¼</h1>
        <p style="font-size: 18px; margin-bottom: 10px;">ä½ çš„æœ€çµ‚åˆ†æ•¸</p>
        <div class="stat-big" id="finalScore">0</div>
        
        <div class="high-score-display">
            <div class="high-score-label">æ­·å²æœ€é«˜åˆ†</div>
            <div class="high-score-value" id="highScore">0</div>
            <div class="record-info" id="highScoreDate">--</div>
        </div>

        <button class="btn" onclick="startGame()">ğŸ”„ å†ä¾†ä¸€æ¬¡</button>
    </div>
</div>

<script>
/**
 * ========================================
 * 1. éŸ³æ•ˆç³»çµ± (Web Audio API)
 * ========================================
 */
class SynthAudio {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = false;
    }

    init() {
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        this.enabled = true;
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled) return;
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        } catch (e) {
            console.warn('Audio error:', e);
        }
    }

    playPop() {
        this.playTone(500 + Math.random() * 300, 'sine', 0.12, 0.15);
    }

    playError() {
        this.playTone(180, 'sawtooth', 0.25, 0.12);
    }

    playSuccess() {
        this.playTone(800, 'triangle', 0.1, 0.08);
        setTimeout(() => this.playTone(1200, 'triangle', 0.15, 0.08), 80);
    }
}

/**
 * ========================================
 * 2. æ•¸å­¸é‚è¼¯æ ¸å¿ƒ
 * ========================================
 */
class MathEngine {
    constructor() {
        this.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
    }

    isPrime(n) {
        return this.primes.includes(n);
    }

    getFactorPair(n) {
        if (this.isPrime(n)) return null;
        const pairs = [];
        for (let i = 2; i * i <= n; i++) {
            if (n % i === 0) {
                let j = n / i;
                if (i !== 1 && j !== 1 && i !== n && j !== n) {
                    pairs.push([i, j]);
                }
            }
        }
        if (pairs.length === 0) return null;
        return pairs[Math.floor(Math.random() * pairs.length)];
    }

    spawnNumber() {
        const isComposite = Math.random() < 0.65;
        let num;
        let safety = 0;
        do {
            num = Math.floor(Math.random() * 49) + 2;
            const prime = this.isPrime(num);
            if (isComposite && !prime) return num;
            if (!isComposite && prime) return num;
            safety++;
        } while (safety < 100);
        return num;
    }
}

/**
 * ========================================
 * 3. éŠæˆ²ä¸»ç¨‹å¼
 * ========================================
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const audio = new SynthAudio();
const math = new MathEngine();

let gameState = 'MENU';
let lastTime = 0;
let score = 0;
let timeLeft = 60;
let bubbles = [];
let particles = [];
let floatingTexts = [];

let difficulty = {
    speedMultiplier: 1.0,
    spawnCount: 1,
    maxBubbles: 4,
    consecutiveCorrect: 0,
    consecutiveWrong: 0,
    hintMode: false
};

const bubbleColors = ['#FF9A9E', '#A18CD1', '#FBC2EB', '#8FD3F4', '#84FAB0', '#FFD93D'];

let width, height, scale, safeTop, safeBottom;

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    scale = dpr;
    safeTop = height * 0.15;
    safeBottom = height * 0.85;
}
window.addEventListener('resize', resize);
resize();

/**
 * ========================================
 * 4. é¡åˆ¥å®šç¾©
 * ========================================
 */
class Bubble {
    constructor(x, y, value, vx, vy) {
        this.x = x;
        this.y = y;
        this.value = value;
        this.radius = Math.min(width, height) * 0.09;
        this.vx = vx;
        this.vy = vy;
        this.isPrime = math.isPrime(value);
        this.color = bubbleColors[Math.floor(Math.random() * bubbleColors.length)];
        this.shake = 0;
        this.age = 0; // ã€æ–°å¢ã€‘æ³¡æ³¡å­˜æ´»æ™‚é–“
        
        // ã€é—œéµä¿®æ”¹ã€‘è³ªæ•¸æ³¡æ³¡ä¸‹è½é€Ÿåº¦æ›´å¿«
        if (this.isPrime) {
            this.vy = Math.abs(this.vy) * 1.8; // è³ªæ•¸ä¸‹è½é€Ÿåº¦ 1.8 å€
            this.vx *= 0.5; // æ¸›å°‘æ©«å‘ç§»å‹•
        }
    }

    update(dt) {
        this.age += dt;
        if (this.shake > 0) this.shake -= dt * 10;

        // ã€é—œéµä¿®æ”¹ã€‘è³ªæ•¸æ³¡æ³¡è¶…é 3 ç§’è‡ªå‹•åŠ é€Ÿä¸‹è½
        if (this.isPrime && this.age > 3.0) {
            this.vy += 0.5; // æŒçºŒåŠ é€Ÿ
            this.vy = Math.min(this.vy, 8); // æœ€å¤§é€Ÿåº¦é™åˆ¶
        }

        this.x += this.vx * dt * 60;
        this.y += this.vy * difficulty.speedMultiplier * dt * 60;

        // é‚Šç•Œåå½ˆ
        if (this.x < this.radius) { 
            this.x = this.radius; 
            this.vx *= -1; 
        }
        if (this.x > width - this.radius) { 
            this.x = width - this.radius; 
            this.vx *= -1; 
        }
        
        // ã€ä¿®æ”¹ã€‘è³ªæ•¸ç¢°åˆ°ä¸Šé‚Šç•Œä¸åå½ˆï¼Œç›´æ¥ç©¿éï¼ˆç¢ºä¿å¾€ä¸‹æ‰ï¼‰
        if (this.y < safeTop + this.radius) {
            if (this.isPrime) {
                this.y = safeTop + this.radius;
                this.vy = Math.abs(this.vy); // å¼·åˆ¶å‘ä¸‹
            } else {
                this.y = safeTop + this.radius;
                this.vy *= -1;
            }
        }

        // æ³¡æ³¡é–“ç¢°æ’
        for (let other of bubbles) {
            if (other === this) continue;
            let dx = this.x - other.x;
            let dy = this.y - other.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let minDist = this.radius + other.radius;

            if (dist < minDist && dist > 0) {
                let force = (minDist - dist) / dist;
                let fx = dx * force * 0.5;
                let fy = dy * force * 0.5;
                this.x += fx;
                this.y += fy;
                other.x -= fx;
                other.y -= fy;

                // ã€æ–°å¢ã€‘è³ªæ•¸ç¢°æ’å¾Œç¢ºä¿å‘ä¸‹ç§»å‹•
                if (this.isPrime && this.vy < 0) {
                    this.vy = Math.abs(this.vy);
                }
            }
        }
    }

    draw() {
        let drawX = this.x + (Math.random() - 0.5) * this.shake * 10;
        ctx.save();
        ctx.translate(drawX, this.y);

        // ã€æ–°å¢ã€‘è³ªæ•¸æ³¡æ³¡è¶…é 3 ç§’æœƒé–ƒçˆæç¤º
        if (this.isPrime && this.age > 3.0) {
            const pulse = Math.sin(this.age * 8) * 0.5 + 0.5;
            ctx.shadowBlur = 15 + pulse * 15;
            ctx.shadowColor = '#FFD93D';
        }

        if (difficulty.hintMode && !this.isPrime) {
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#FFD93D';
        }

        // æ³¡æ³¡æ¼¸å±¤
        const gradient = ctx.createRadialGradient(
            -this.radius * 0.3, -this.radius * 0.3, 0,
            0, 0, this.radius
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, this.color + 'CC');

        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // é«˜å…‰
        ctx.beginPath();
        ctx.arc(-this.radius * 0.35, -this.radius * 0.35, this.radius * 0.25, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fill();

        // æ•¸å­—
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${this.radius * 0.85}px 'Varela Round', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 3;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.fillText(this.value, 0, 0);

        ctx.restore();
    }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1.2;
    }
    update(dt) {
        this.y -= 60 * dt;
        this.life -= dt;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.font = "bold 32px 'Varela Round', sans-serif";
        ctx.textAlign = 'center';
        ctx.shadowBlur = 5;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.fillText(this.text, this.x, this.y);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 250;
        this.vy = (Math.random() - 0.5) * 250;
        this.life = 0.6 + Math.random() * 0.4;
        this.radius = Math.random() * 6 + 3;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life -= dt;
    }
    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

/**
 * ========================================
 * 5. éŠæˆ²é‚è¼¯å‡½æ•¸
 * ========================================
 */
function spawnBubble() {
    if (bubbles.length >= difficulty.maxBubbles) return;

    let val = math.spawnNumber();
    let r = Math.min(width, height) * 0.09;
    let x = Math.random() * (width - r * 2) + r;
    let y = safeTop + r + 15;

    bubbles.push(new Bubble(x, y, val, (Math.random() - 0.5) * 1.8, Math.random() * 1.5 + 0.8));
}

function checkSmartSpawn() {
    const hasComposite = bubbles.some(b => !b.isPrime);
    if (!hasComposite && bubbles.length < 3) {
        spawnBubble();
    }
}

// ã€æ–°å¢ã€‘å¼·åˆ¶æ¸…ç†é•·æ™‚é–“åœç•™çš„è³ªæ•¸æ³¡æ³¡
function forceCleanupPrimes() {
    for (let i = bubbles.length - 1; i >= 0; i--) {
        let b = bubbles[i];
        // è³ªæ•¸æ³¡æ³¡è¶…é 8 ç§’è‡ªå‹•ç§»é™¤ï¼ˆæ¥µç«¯æƒ…æ³ï¼‰
        if (b.isPrime && b.age > 8.0) {
            score += 50; // çµ¦äºˆéƒ¨åˆ†åˆ†æ•¸
            audio.playSuccess();
            floatingTexts.push(new FloatingText(b.x, b.y, "+50 â°", "#42B983"));
            createParticles(b.x, b.y, '#FFD700');
            bubbles.splice(i, 1);
        }
    }
}

function handleDifficulty(isCorrect) {
    if (isCorrect) {
        difficulty.consecutiveCorrect++;
        difficulty.consecutiveWrong = 0;
        if (difficulty.consecutiveCorrect >= 5) {
            difficulty.speedMultiplier = Math.min(difficulty.speedMultiplier + 0.15, 2.0);
            difficulty.spawnCount = Math.min(difficulty.spawnCount + 1, 2);
            difficulty.maxBubbles = Math.min(difficulty.maxBubbles + 1, 5);
            difficulty.consecutiveCorrect = 0;
            difficulty.hintMode = false;
        }
    } else {
        difficulty.consecutiveWrong++;
        difficulty.consecutiveCorrect = 0;
        if (difficulty.consecutiveWrong >= 2) {
            difficulty.speedMultiplier = Math.max(difficulty.speedMultiplier - 0.1, 0.6);
            difficulty.spawnCount = Math.max(difficulty.spawnCount - 1, 1);
            difficulty.maxBubbles = Math.max(difficulty.maxBubbles - 1, 3);
            difficulty.consecutiveWrong = 0;
            difficulty.hintMode = true;
        }
    }
}

function createParticles(x, y, color) {
    for (let i = 0; i < 10; i++) particles.push(new Particle(x, y, color));
}

function handleInput(clientX, clientY) {
    if (gameState !== 'PLAYING') return;

    for (let i = bubbles.length - 1; i >= 0; i--) {
        let b = bubbles[i];
        let dist = Math.sqrt((clientX - b.x) ** 2 + (clientY - b.y) ** 2);

        if (dist < b.radius * 0.85) {
            if (b.isPrime) {
                b.shake = 1.0;
                audio.playError();
                score = Math.max(0, score - 50);
                floatingTexts.push(new FloatingText(b.x, b.y, "-50 ğŸ˜¢", "#FF6B6B"));
                handleDifficulty(false);
            } else {
                audio.playPop();
                score += 10;
                createParticles(b.x, b.y, b.color);

                let factors = math.getFactorPair(b.value);
                bubbles.splice(i, 1);

                if (factors) {
                    let b1 = new Bubble(b.x - 25, b.y, factors[0], b.vx - 1.2, b.vy - 0.6);
                    let b2 = new Bubble(b.x + 25, b.y, factors[1], b.vx + 1.2, b.vy - 0.6);
                    bubbles.push(b1, b2);
                }

                handleDifficulty(true);
            }
            return;
        }
    }
}

canvas.addEventListener('pointerdown', (e) => {
    handleInput(e.clientX, e.clientY);
});

/**
 * ========================================
 * 6. ä¸»è¿´åœˆ
 * ========================================
 */
let spawnTimer = 0;
let cleanupTimer = 0; // ã€æ–°å¢ã€‘æ¸…ç†è¨ˆæ™‚å™¨

function update(dt) {
    timeLeft -= dt;
    if (timeLeft <= 0) {
        gameOver();
        return;
    }

    spawnTimer += dt;
    cleanupTimer += dt;

    // ã€æ–°å¢ã€‘æ¯ 2 ç§’æª¢æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦å¼·åˆ¶æ¸…ç†
    if (cleanupTimer > 2.0) {
        forceCleanupPrimes();
        cleanupTimer = 0;
    }

    let baseSpawnTime = timeLeft > 30 ? 4.5 : 3.0;
    let realSpawnTime = baseSpawnTime / difficulty.speedMultiplier;

    if (spawnTimer > realSpawnTime) {
        for (let k = 0; k < difficulty.spawnCount; k++) spawnBubble();
        spawnTimer = 0;
    }
    checkSmartSpawn();

    for (let i = bubbles.length - 1; i >= 0; i--) {
        let b = bubbles[i];
        b.update(dt);

        if (b.y > safeBottom) {
            if (b.isPrime) {
                score += 100;
                audio.playSuccess();
                floatingTexts.push(new FloatingText(b.x, b.y - 50, "+100 ğŸ‰", "#42B983"));
                createParticles(b.x, b.y, '#FFD700');
            } else {
                score = Math.max(0, score - 20);
                audio.playError();
                floatingTexts.push(new FloatingText(b.x, b.y - 50, "-20 ğŸ’”", "#FF6B6B"));
                handleDifficulty(false);
            }
            bubbles.splice(i, 1);
        }
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        floatingTexts[i].update(dt);
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
    }
}

function draw() {
    ctx.clearRect(0, 0, width, height);
    bubbles.forEach(b => b.draw());
    particles.forEach(p => p.draw());
    floatingTexts.forEach(t => t.draw());

    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('timeDisplay').textContent = Math.ceil(timeLeft);
}

function loop(timestamp) {
    if (gameState !== 'PLAYING') return;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if (dt > 0.1) dt = 0.1;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

/**
 * ========================================
 * 7. æˆç¸¾è¨˜éŒ„ç³»çµ±
 * ========================================
 */
function saveScore(currentScore) {
    const rawData = localStorage.getItem('mathBubbleRecord');
    let record = rawData ? JSON.parse(rawData) : { score: 0, date: '--' };

    if (currentScore > record.score) {
        const now = new Date();
        const dateStr = `${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, '0')}/${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        record = { score: currentScore, date: dateStr };
        localStorage.setItem('mathBubbleRecord', JSON.stringify(record));
    }
    return record;
}

function loadHighScore() {
    const rawData = localStorage.getItem('mathBubbleRecord');
    if (rawData) {
        return JSON.parse(rawData);
    }
    return { score: 0, date: 'å°šç„¡ç´€éŒ„' };
}

/**
 * ========================================
 * 8. éŠæˆ²æµç¨‹æ§åˆ¶
 * ========================================
 */
function startGame() {
    audio.init();
    audio.ctx.resume();
    
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('endScreen').classList.add('hidden');

    score = 0;
    timeLeft = 60;
    bubbles = [];
    particles = [];
    floatingTexts = [];
    difficulty = {
        speedMultiplier: 1.0,
        spawnCount: 1,
        maxBubbles: 4,
        consecutiveCorrect: 0,
        consecutiveWrong: 0,
        hintMode: false
    };

    spawnBubble();
    gameState = 'PLAYING';
    lastTime = performance.now();
    requestAnimationFrame(loop);
}

function gameOver() {
    gameState = 'END';
    document.getElementById('endScreen').classList.remove('hidden');

    document.getElementById('finalScore').textContent = score;

    const record = saveScore(score);
    document.getElementById('highScore').textContent = record.score;
    document.getElementById('highScoreDate').textContent = record.date;
}

// é é¢è¼‰å…¥æ™‚é¡¯ç¤ºæœ€é«˜åˆ†
window.addEventListener('DOMContentLoaded', () => {
    const saved = loadHighScore();
    document.getElementById('homeHighScore').textContent = saved.score;
    document.getElementById('homeHighScoreDate').textContent = saved.date;
});

// ç¢ºä¿å­—é«”è¼‰å…¥
document.fonts.ready.then(() => {
    console.log('âœ… å­—é«”å·²è¼‰å…¥');
});

// é˜²æ­¢ iOS Safari é›™æ“Šç¸®æ”¾
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        e.preventDefault();
    }
    lastTouchEnd = now;
}, false);

// é˜²æ­¢é•·æŒ‰é¸å–®
document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
});

</script>
</body>
</html>